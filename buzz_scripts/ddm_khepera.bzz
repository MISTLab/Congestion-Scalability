include "includes/vec2.bzz"
include "includes/RVO.bzz"
include "includes/neighbors.bzz"
include "includes/table.bzz"


scaling_light_factor = 50
obstacle_threshold = 0.02
max_speed = 50
ang_range =  10 * math.pi / 180
white_threshold = 0.75
black_threshold = 0.25
time_threshold = 50
delta_time = 20

zone = "nest"

white = 1 
black = -1

number_of_samples = 50  
belief = 0.5
new_belief = 0.5

sample_average = 0.0
neighbors_set = nil
white_neighbors_set = nil
black_neighbors_set = nil
samples = {}
time_steps = 0


white_followers = swarm.create(3)
black_followers = swarm.create(2)
nesters = swarm.create(5)
decision_makers = swarm.create(6)
white_exploration = swarm.create(1)
black_exploration = swarm.create(4)
beacons = swarm.create(7)




function sum_light(rid, data, accum) {
  lvec = math.vec2.newp(data.value, data.angle)
  accum.vector = math.vec2.add(lvec, accum.vector)
  if (data.value!=0) { #counting the number of light sensors that are good 
   accum.number = accum.number +1
  }
  return accum
}

# Filtering Light Function
function filtered_light() {
  var filtered_data = reduce(light, sum_light, {.number = 0 , .vector=math.vec2.new(0.0,0.0)})
  return filtered_data
}

# Obstacle avoidance function
function obs_vec()
{
  var accum = {}
  accum.x = 0.0
  accum.y = 0.0
  var i = 0
  while(i < size(proximity)) {
	accum.x = accum.x + proximity[i].value * math.cos(proximity[i].angle)
	accum.y = accum.y + proximity[i].value * math.sin(proximity[i].angle)
	i = i + 1
  }
  accum.x = accum.x / size(proximity)
  accum.y = accum.y / size(proximity)


  #debug.print("[",id,"]",math.vec2.length(light_vector)," .x ",light_vector.x," .y ",light_vector.y)
  return accum
}

# function to sum the ground sensor values
function sum_ground(rid, data, accum) {
   return accum + data.value
}

# function to calculate the average ground sensor value
function avg_ground() {
    var ground_avg = reduce(ground, sum_ground, 0.0)
    ground_avg = ground_avg / size(ground)
    return ground_avg
}

function display_led(){
    if (white_followers.in()){ 
        set_leds(255,255,255) 
    }
	if (black_followers.in()){ 
        set_leds(0,0,0) 
    }
    if (black_exploration.in()){ set_leds(255,0,0) }
    if (white_exploration.in()){ set_leds(0,255,0) }
    if (nesters.in()){ set_leds(0,0,255) }
    if (decision_makers.in()){ 
        if (belief == 1){
        set_leds(0,255,255) 
        }
        else if(belief == -1){
        set_leds(255,255,0)
        }
    }

    if (beacons.in()){
        if (id < 105) {
        set_leds(255,255,255)
        }
        else {
        set_leds(0,0,0)    
        } 
    }
}


function explore_avoid() {
    var obs_vector = obs_vec()
    var obs_vector_len = math.vec2.length(obs_vec())
    var obs_ang = math.atan(obs_vector.y, obs_vector.x)

    if (obs_ang > -ang_range and obs_ang < ang_range and obs_vector_len < obstacle_threshold){
        goto(max_speed, 0.0)
    }
    
    else{
        obs_vector = math.vec2.scale(obs_vector, -1.0*max_speed/obs_vector_len)
  	    goto(obs_vector.x, obs_vector.y)
    }

}

function follow_avoid(direction) {    
    var light_vector = filtered_light().vector
    var obs_vector = obs_vec()
    var light_vector_len = math.vec2.length(light_vector)
    var obs_vector_len = math.vec2.length(obs_vec())
    var obs_ang = math.atan(obs_vector.y, obs_vector.x)

    if (obs_ang > -ang_range and obs_ang < ang_range and obs_vector_len < obstacle_threshold){
        light_vector = math.vec2.scale(light_vector, direction*scaling_light_factor/light_vector_len)
        goto(light_vector.x, light_vector.y)
    }

    else {
        obs_vector = math.vec2.scale(obs_vector, -1.0*max_speed/obs_vector_len)
  	    goto(obs_vector.x, obs_vector.y)
    }

}

function collect_samples(){
    if (not samples){
        samples = {.1 = avg_ground()}
    }
    else {
    samples[size(samples)+1] = avg_ground()
    }
    sample_average = sample_average + avg_ground()  
}

function add_value_to_set(set, key, value){
    if (not set[key]){
        set[id] = {}
    }
    set[key] = value
}

function size_of_array(array){
    if (not array){
        return 0
    }
    else {
        return size(array)
    }
}



function collect_neighbours(){
    neighbors.collect("opinions", id, new_belief, zone_collected)
}



function init() {

    neighbors.listen("zones", function(rid, data) {
        if (id < 100){
            if (data.zone == "white"){
                zone = "white"
            }
            if (data.zone == "black"){
                zone = "black"
            }
        }
    })


	white_followers.select(id % 2 == 0 and id < 100)
	black_followers.select((id+1) % 2 == 0  and id < 100)
    beacons.select(id >= 100)

    if (black_followers.in()){ 
        belief = black
    }
    if (white_followers.in()){ 
        belief = white
    }
    samples = nil 
    sample_average = 0.0

}



function step() {

    debug.print("id: ", id,  " zone: ", zone, " estimate: ", new_belief)
    display_led()

    if (beacons.in()){
        if (id >= 100 and id < 105){
        neighbors.broadcast("zones", {.id=id, .zone = "white"})
        }
        if (id >= 105 and id < 110){
        neighbors.broadcast("zones", {.id=id, .zone = "black"})
        }
    }


    if(white_followers.in()){
        
        follow_avoid(white)
        if (zone == "white") {
            white_exploration.join()
            white_followers.leave()
        }


    }

    if(black_followers.in()) {

        follow_avoid(black)
        if(zone == "black") {
            black_exploration.join()
            black_followers.leave()
        }

    }

    if(black_exploration.in()) {


        if (zone == "black"){
            explore_avoid()
            collect_samples()
            if (size(samples) >= number_of_samples){
                new_belief = sample_average/number_of_samples
                zone_collected = black
                black_exploration.leave()
                nesters.join()
            }
        }
        
        else {
            zone = "nest"
            black_followers.join()
            black_exploration.leave()
        }
        
    
    }


    if(white_exploration.in()) {

        if (zone == "white"){
            explore_avoid()
            collect_samples()
            if (size(samples) >= number_of_samples){
                new_belief = sample_average/number_of_samples
                zone_collected = white
                white_exploration.leave()
                nesters.join()
            }
        }

        else {
            zone = "nest"
            white_followers.join()
            white_exploration.leave()
        }
        
    
    }

    if (nesters.in()){
        
        if (zone == "nest"){
            decision_makers.join()
            nesters.leave()
        }
        else {
            if (zone == "white"){
                follow_avoid(black)
            }
            else if(zone == "black"){
                follow_avoid(white)
            }
            
        }

    }

    if (decision_makers.in()){
        
        time_steps = time_steps + 1
        explore_avoid()
        if (zone == "white" or zone == "black"){
            decision_makers.leave()
            nesters.join()
        }

        
        if (time_steps > time_threshold - delta_time ){
            debug.print("id: ", id, " broadcasting and collecting ")
            neighbors.broadcast("opinions",{.id=id,.belief=new_belief,.zone_collected=zone_collected})
            collect_neighbours()
        }

        if (time_steps > time_threshold){
            
            debug.print("id: ", id, " decision_making.... ")

            if (neighbors.msgs["opinions"]["aggregate"] > 0)
            {white_followers.join()}

            else if (neighbors.msgs["opinions"]["aggregate"] < 0)
            {black_followers.join()}

            else{
                if (zone_collected == white){
                    white_followers.join()
                }
                else if (zone_collected == black){
                    black_followers.join()
                }
            }

            
            log(id," white_neighbors_set ", neighbors.msgs["opinions"]["white"], " black_neighbors_set ", 
            neighbors.msgs["opinions"]["black"], " aggregate ", neighbors.msgs["opinions"]["aggregate"], "zone_collected ",
            zone_collected," new_belief ", new_belief)


            neighbors.ignore("opinions")
            neighbors.reset("opinions")
            

            samples = nil
            time_steps = 0
            sample_average = 0.0
            new_belief = 0.0
            
            decision_makers.leave()

        
        }


    }

    zone = "nest" #clear zone for next step


}




function reset() {

}


function destroy() {

}
